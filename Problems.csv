题号,名称,完成日期,难度,思路,,,题量全球排名,竞赛全国排名,竞赛全球排名
935,骑士拨号器,2019/10/18,中,动态规划,逐轮递推，从第一轮开始，每轮记录下出现某个数字的可能总数，用以计算下一轮的可能总数,,,,
327,区间和的个数,2019/10/26,高,前缀和,参考了363的思路，将复杂度控制在O(NlogN)，前缀和数组的生成和查询都用了二分搜索，提高了性能,,,,
165,比较版本号,2019/10/27,中,常规方法，依次找分隔符，判断每段的大小 ,其他方法：用split函数+zip_longest,,,,
451,根据字符出现频率排序,2019/10/27,中,常规思路,先遍历一遍，构造每个字符的次数的字典，再将字典排序,,,,
503,下一个更大元素 II,2019/11/2,中,单调栈,"个人解法：顺序遍历两次，用一个单调递增的列表存放未找到Greater的元素，下个元素c依次与递增序列元素比较，只要比c小的元素的Greater就是这个c，直至遇到>=c的元素，并把c放到递增序列头部
此方法缺点：需要用一个字典保存递增列表的每个元素在原列表中的位置","其他解法：反序处理，并将原始数组 “翻倍”，就是在后面再接一个原始数组
优点：不需要另外的字典，逐个查找即可",,,
1128,等价多米诺骨牌对的数量,2019/11/3,低,常规思路,将与第一个dominoes相同的dominoes全部找出来，计算总个数为N，那么pair就有N * (N-1)/2个，把这些元素全部删除，再重复前面的操作,,,,
912,排序数组,2019/11/4,中,快速排序,可以参数别人十种排序方法 https://github.com/DangoSky/algorithm/blob/master/DataStructure-homework/Experiment%EF%BC%88C%2B%2B%EF%BC%89/%E5%AE%9E%E9%AA%8C%E5%9B%9B%EF%BC%9A%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F.cpp,,,,
30,串联所有单词的子串,2019/11/16,高,常规方法,"充分利用每个单词的长度是相同的这一特性
1、按每个word的长度，如长度是4，则外层循环是4次
2、内层循环用一个字典d保存尚未被匹配到的word及其未匹配的个数
   pos_begin表示当前开始位置，pos_cur表示当前比较的word位置
   每次比较s的一个word长度的子串，如果在d中，且value>0,则将d中的value减1，移动pos
                                  value==0,移动pos
                                  如果不在d中，则从下个word重现计数d，移动pos
   ",,,,
862,和至少为 K 的最短子数组,2019/11/30,困难,前缀和,"自己的方法性能不够，使用前缀和，每次把下个前缀和插入已经排序的数组之中，再进行选择，降低了性能
参考答案：总结了题目要求的两个性质，只考虑一个单调增的前缀和数组
每次插入只需从末尾，提高了性能。
我们用 opt(y) 表示对于固定的 y，最大的满足 P[x] <= P[y] - K 的 x，这样所有 y - opt(y) 中的最小值即为答案。我们可以发现两条性质：

(1) 如果 x1 < x2 且 P[x2] <= P[x1]，那么 opt(y) 的值不可能为 x1，这是因为 x2 比 x1 大，并且如果 x1 满足了 P[x1] <= P[y] - K，那么 P[x2] <= P[x1] <= P[y] - K，即 x2 同样满足 P[x2] <= P[y] - K。

(2) 如果 opt(y1) 的值为 x，那么我们以后就不用再考虑 x 了。这是因为如果有 y2 > y1 且 opt(y2) 的值也为 x，但此时 y2 - x 显然大于 y1 - x，不会作为所有 y - opt(y) 中的最小值。",,,,
1071,字符串的最大公因子,2019/11/30,简单,最大公约数,"个人解法：求两个字符串长度的最大公约数，这是公约数子串的长度上限，从这个长度开始依次验证每个字串是否是两个字串的最大公约数字串
参考答案：先判断：str1 + str2 == str2 + str1 ，不满足则无解
满足，则最大公约长度的字串就是最大公约数字串",,,,
674,最长连续递增序列,2019/12/1,简单,滑动窗口,常规解法，遍历一遍的过程中，单调递增的前一个节点和首个节点,,,,
515,在每个树行中找最大值,2019/12/8,中等,广度优先,"个人解法：利用BFS将树转化为双向列表，其中树的每层通过分隔符分割，再对每段获取最大值
其他解法：DFS",,,,
208,实现 Trie (前缀树),2019/12/10,中等,前缀树,,,,,
1233,删除子文件夹,2019/12/14,中等,先排序，再计算,"可以考虑O(N*N)复杂度的普通算法，两层循环，结果超时
后来想到先排序，再一轮循环筛选，利用系统函数sort降低复杂度",,,,
162,寻找峰值,2019/12/20,中等,二分法,基于相邻两个元素互不相同这个条件，使用二分法，每次减半搜索区域,,,,
383,赎金信,2019/12/22,简单,常规方法,将其中一个字符串转换成字典，记录引用次数，再进行一轮查找,"from collections import defaultdict
mag_dic = defaultdict(int)
带默认值的字典",,,
1290,二进制链表转整数,2019/12/22,简单,常规方法,二进制数左移就是乘以2,,,,
1266,访问所有点的最小时间,2019/12/23,简单,常规方法,"两点的距离=max(|x0-x1|,|y0-y1|)","for idx, p in enumerate(points[1:])",30320,,
851,喧闹和富有,2019/12/25,中等,DFS递归,在扫描richer数组的同时，更新返回值序列,graph = [[] for _ in xrange(N)],30320,,
415,字符串相加,2019/12/26,简单,常规方法,短的数字左端补零后，从右向左加法运算，注意进位,,,,
995,K 连续位的最小翻转次数,2019/12/28,困难,滑动窗口+贪心算法,"思路：从前向后找第一个0，从这个0开始翻转K的数，继续找0，再翻转，直至结束，看是否能完成，因为一个数翻转2次就还原，可以证明找到一种方法之后，这钟方法中的翻转次序是可以任意调换的，如：先翻转2,3,4再翻转3，4，5和先翻转3，4，5后翻转2，3，4是一样的
个人解法：递归，找到0之后就翻转，然后从0的位置递归调用
根据官方解法，自己修正后，用flip数组记录每次翻转的结束位置，每次翻转或遇到flip[i]为1的位置，调整搜索target，从1变成0，或从0变成1，每轮循环只需要关注当前的值和target是否相同，并不需要关系从当前值开始的所有K个值",,,,
1289,下降路径最小和  II,2020/1/5,困难,递推，动态规划,"(1)开始思路：一层层递推，F[i,j]表示第i行选第j个元素时，前i行的最小值
加入计算出F[i,j],那么F[i+1,j]=min(F[i,j])+arr[i+1,j] (对于所有i!=j求最小值)
代码较少，但复杂度较高,约为O(N*N*N)
(2)减少复杂度：考虑每行只需要找出最小的三个数参与递推计算即可，不需要计算所有N个数的F值，只需要写个topK的函数即可
简单证明：假如最小值的某行取值不是top3中的一个数，则在top3中的数肯定有一个是与相邻行不同的，用这个数替代原来的数，组成的数列比之前的最小值要小
至于top3假如有超过3个数时（有相同的），这个证明？？
假如最优解经过arr[i,j]，且arr[i,j]不属于这行的top3，那么至少存在2个在top3中的元素的F值不大于F[i,j]，即F[i,j]>=F[i,t1]和F[i,j]>=F[i,t2]。假如F[i,j]<F[i,t3],那么t1和t2中至少有一个满足：F[i+1,j]>=F[i+1,t]，因此总能将top3之外的一个元素，转化为top3之中的一个元素，放入最优解中，使得最优解不比选arr[i,j]大
（3）官方题解给出了另一种思路，把(1)改进一下：
f[i][j] = f[i - 1][jmin[i - 1]] + arr[i][j]    其中 j != jmin[i - 1]
f[i][j] = f[i - 1][jnext[i - 1]] + arr[i][j]   其中 j == jmin[i - 1]
f[0][j] = arr[0][j]
https://leetcode-cn.com/problems/minimum-falling-path-sum-ii/solution/xia-jiang-lu-jing-zui-xiao-he-ii-by-leetcode/","min(F2, key=lambda x:x[0])[0]",29693,,
116,填充每个节点的下一个右侧节点指针,2020/1/12,中等,BFS,常规的BFS方法遍历,,29907,,
811,子域名访问计数,2020/1/15,简单,常规方法,"个人解法：域名字符串从右向左找 '.'，最多找两个，个域名放入字典计数
官方题解：方法类似，用法比较简洁","def subdomainVisits(self, cpdomains):
        ans = collections.Counter()
        for domain in cpdomains:
            count, domain = domain.split()
            count = int(count)
            frags = domain.split('.')
            for i in xrange(len(frags)):
                ans[""."".join(frags[i:])] += count

        return [""{} {}"".format(ct, dom) for dom, ct in ans.items()]",29756,,
1291,顺次数,2020/1/17,中等,常规方法,个人解法：计算出下界的位数，构造最小顺次数，依次加11或111或1111递增,,29541,,
338,比特位计数,2020/1/23,中等,常规方法,"个人解法：
0
1
1，2
1，2，2，3
1，2，2，3，2，3，3，4
可以总结规律：每行表示[2^n,2^(n+1) - 1], 每行的数字是上面所有行的数字依次加一的序列",,29593,,
686,重复叠加字符串匹配,2020/1/24,简单,常规方法,"个人解法：(1) 首先处理特殊场景，lenA >= lenB时，检查B是否时A或A+A的字串
(2) lenA*2 >= lenB时，检查B是否时A+A字串
(3) 剩余情况，检查B的结构是否是这种形式：C1A...AC2,其中C1是A的尾部，C2是A的头部，满足这种形式的B，能得到非-1的解
别人解法：A叠加后的最大长度是2*A.length+B.length2?A.length+B.length
将A扩张s = A * math.ceil((len(A) * 2 + len(B)) / len(A))，在s中找
此法代码量小",,29292,,
985,查询后的偶数和,2020/1/25,简单,常规方法,个人解法：修改数字前判断之前的数值的奇偶性，避免每次求和,技巧，求偶数和：sum(x for x in A if x % 2 == 0),28946,,
805,数组的均值分割,2020/1/29,困难,折半搜索+归并排序,"个人解法：因为A的平均值和B、C的平均值相同，所以根据B的元素个数可以计算出B中的元素和
依次计算B的元素个数是1，2，...，N/2时，是否能找到对应的集合，recursiveFind(L, Sum, N): # 在L中找N个数，使之和为Sum
利用递归求解，但复杂度太高，不能通过
别人解法：将A每个元素*N-sum(A),再分成两个部分A1，A2元素个数尽量相同，分别计算A1和A2中各个元素的可能和（任意一个元素的和，任意二个元素的和，。。。），分别形成两个集合S1和S2，如果存在S1和S2中的两个元素和为0，则说明存在一组A中的数字的均值为sum(A)/N(需要排除掉这组数字是所有A中元素)，计算过程可以排序A1，A2和S1，S2中的数，降低复杂度",关于二分法的一个库：bisect.insort,28747,,
952,按公因数计算最大组件大小,2020/2/1,困难,并查集,"个人解法：先把每个数独立放在一个列表中，依次用每个素数去整除每个列表中各个数，把所有列表中包含能整除这个素数的列表找出来，合并所有这些列表，复杂度比较高
别人解法：使用并查集，A中 每个元素与自己的所有因子做并查集的union，最后形成的并查集从中查看元素最多的集合","for num in A:
    up_bound = int(sqrt(num))
    for i in range(2, up_bound + 1):
这样性能比
for i in A:
    j = 2
    while j*j <= i:
高，因为j*j每次内循环都会做一次，但sqrt内层循环只做一次，另外，测试结果：这样的内层for循环比while循环效率高，可能range里面对循环变量有优化处理
并查集中，union方法的
self.parent[x] = self.parent[self.parent[x]]
这步操作很关键，会影响性能",28626,,
412,Fizz Buzz,2020/2/2,简单,常规方法,用多次循环，减少判断次数,,28479,,
316,去除重复字母,2020/2/8,困难,栈,"个人解法不正确
别人解法：简洁，遍历字符串，依次取出元素，如果发现栈中存在跳过，否则依次替换掉栈顶的元，只有满足：占中元素在字符串后面还存在，并且栈顶元素大于当前元素",'.join(stack),28697,,
191,位1的个数,2020/2/9,简单,常规方法,"个人解法：左移或除以2
其他解法：不断 n &= (n - 1)直至为0
n & (n - 1) 能每次把一个1变成0",,28356,,
88,合并两个有序数组,2020/2/9,简单,常规方法,双指针 / 从后往前,,28356,,
1191,K 次串联后最大子数组之和,2020/2/15,中等,动态规划,"采用最大连续字串的思路，同时得到一个arr中的最大字串和，最大前缀和，最大后缀和
K>1时，最大字串可能有几种情况：
1：就是arr的最大字串
2：跨越两个arr，这样就是最大前缀和最大后缀之和
3：第一arr的后缀+K-2个arr+最后一个前缀",from typing import List,28257,,
310,最小高度树,2020/2/16,中等,图论,"个人解法：根据题目推出，最小高度树根节点应该位于最长路径的中点处，可能时一个或两个中点
于是任选一个点为根节点，依次求出所有节点的高度（所有子节点的高度最大值，叶子节点高度为1）。如果根节点的高度为N，其子节点至少有一个高度为N-1，
1、如果有另外一个子节点高度也是N-1，说明这个根节点就是最长路径中点，
2、否则，如果存在子节点高度为N-2，说明root和高度为N-1的子节点为最长路径中点
3、否则用高度为N-1的节点替换root，重新计算
此方法可行，但过于复杂
其他解法：不断删除树上叶子节点，最后剩下的一个点或两个点就是所求",,28031,,
664,奇怪的打印机,2020/2/22,困难,动态规划,"未做出来
使用动态规划递推
s[i,j]表示s中第i个字母到第j个字母这个子串
dp[i,j]表示子串s[i,j]的最少打印次数，下面仅考虑dp[i,j]的计算方法
① s[i]这个字母只需在一次中打印，且总可以在第一次打印（因为他是首字母，后续打印不需要覆盖到它）。因为最优解可能有多种，设最优解中包含s[i]的那次最短长度的打印为 P，结束点为k
② P这次打印的结尾字符应该与首字母s[i]相同，即s[i]==s[k]（否则，不相同的部分都是多余的打印，只会使得总打印次数更多）
③ P这次打印最后一个字符s[k]应该只被打印一次，即s[i]，s[k]在同一次被打印，且仅在这次中被打印（否则，P这次打印不需要包含s[k]）
④ s[i,j]被分成两段，s[i,k]和s[k+1,j],最优打印法中的任何一次打印不会跨越这两段（因为分界点s[k]只被打印一次）。当然s[k]可能就是s[j]，这样实际就没有分段，打印P会打印整段s[i,j]
⑤ 在④中的两段上分别递推，就得到：
dp[i,j] = min(dp[i,k] + dp[k+1,j]) 对所以满足s[i]==s[k]的k求min
⑥ 由于s[i]==s[k],可得：dp[i,k] == dp[i,k-1]（因为打印s[i,k-1]的方法只要在第一次把s[i]打印在所有字符上，就能应用在s[i,k]之上了）
于是可以得到新的公式，可以避免k==j的情况：
dp[i,j] = min(dp[i,k-1] + dp[k+1,j])",,28551,,
953,验证外星语词典,2020/2/22,简单,常规方法,"个人解法：用字典保存新order，再挨个比较相邻单词
其他解答：
return words == sorted(words,key=lambda s:''.join(['abcdefghijklmnopqrstuvwxyz'[order.index(i)] for i in s]))",,28551,,
232,用栈实现队列,2020/2/27,简单,常规方法,"官方解法：设两个栈，一个用于push，一个用于pop
入队（push）

新元素总是压入 s1 的栈顶，同时我们会把 s1 中压入的第一个元素赋值给作为队首元素的 front 变量。
出队（pop）

根据栈 LIFO 的特性，s1 中第一个压入的元素在栈底。为了弹出 s1 的栈底元素，我们得把 s1 中所有的元素全部弹出，再把它们压入到另一个栈 s2 中，这个操作会让元素的入栈顺序反转过来。通过这样的方式，s1 中栈底元素就变成了 s2 的栈顶元素，这样就可以直接从 s2 将它弹出了。一旦 s2 变空了，我们只需把 s1 中的元素再一次转移到 s2 就可以了。",,28558,,
521,最长特殊序列,2020/2/28,简单,小技巧,官方解法：长度长的串肯定本身就是最长子序，a==b就返回-1,,28160,,
1011,在 D 天内送达包裹的能力,2020/2/29,中等,二分法,"个人解法：从船容量的下界开始验证是否能在D天内完成运输，不能就把容量+1，直至完成
其他解法，思路相同，可以使用二分搜索加快速度，因为容量上界时sum(weights)",,28160,,
941,有效的山脉数组,2020/2/29,简单,常规方法,,,28160,,
997,找到小镇的法官,2020/3/1,简单,常规方法,其他解法：法官是这样一个点：出度为0，并且入度为N-1,"取字典第一个元素方法：
list(trustedCount.values())[0]
list(trustedCount.keys())[0]",27564,,
804,唯一摩尔斯密码词,2020/3/3,简单,常规方法,"个人解法：转成morse码之后，将.和-看成0和1，转成二进制整数，提高一点set排除的性能，但，要考虑到...---和---的二进制数是相同的，还得加以区别
其他解法：代码简洁，但性能差一点：
seen = {"""".join(MORSE[ord(c) - ord('a')] for c in word)
                for word in words}","dict(zip(alphabetaList, codeList))",27527,,
1190,反转每对括号间的子串,2020/3/5,中等,栈,"个人解法：查找第一个左括号，再找到它对应的右括号，这对括号前的字符直接放在结果中，括号间的字符递归调用再翻转，括号后的字符串直接递归
其他解法：遇到左括号栈顶就压入空串，遇到右括号就反转栈顶并与栈顶第二个元素合并，其他情况栈顶直接累加元素，最后输出栈内唯一元素。","翻转字符串
''.join(reversed(s))",27518,,
836,矩形重叠,2020/3/6,简单,常规方法,个人解法：考虑相交的条件比较复杂，但可以考虑不相交的条件,,27202,,
483,最小好进制,2020/3/7,困难,二分法,"f(k,N) = 1 + k^1 + k^2 + ... + k^(N-1)
个人解法：对于每个k，把f看出N的函数，求出每个k，是否存在一个N使得f(k,N)=num，但k的数量太大，2~N-1，性能不够
其他解法：对于每个N，把f看出k的单调增函数，用二分法找出是否存在某个k使得f(k,N)=num，因为N的范围有限2~log(10^18)=59.xxx，性能较高
int(math.pow(num, 1/(2-1)))当num较大时，此函数计算精度不够",,27202,,
728,自除数,2020/3/8,简单,常规方法,,"其他技巧：提一下 all() 函数，是这样的，如果里面的参数每一项都是 True，那么返回 True，否则返回 False，any() 与之对应。
return [n for n in range(left, right + 1) if \
               '0' not in str(n) and all([n % int(b) == 0 for b in str(n)])]",27051,,
6,Z 字形变换,2020/3/8,中等,常规方法,每行看作一个字符串，依次取出s中元素，放入各行的字符串中,合并字符串列表所有元素,27051,,
322,零钱兑换,2020/3/21,中等,动态规划,"个人解法：设min_num[i]为总金额i所需的最少的硬币个数
递推公式：min_num[N] = min(min_num[k] + min[N-k]) for k < N
性能不够，当N很大时，O(N*N)
其他解法：min_num[N] = min(min_num[k] + 1) for k in coins
复杂度，O(k*N)",,28250,,
1310,子数组异或查询,2020/3/21,中等,前缀和,A xor B = C => B = C xor A,,28250,,
190,颠倒二进制位,2020/3/21,简单,位元算,,,28250,,
653,两数之和 IV - 输入 BST,2020/3/22,简单,常规方法,个人解法：将BST转成有序数组，从数组两端向内侧搜索,,28250,,
1284,转化为全零矩阵的最少反转次数,2020/3/22,困难,,"个人解法：每个点至多翻转一次，且顺序无关，遍历所以这样的翻转可能性，计算最小值
其他解法：优化个人解法，只需穷举第一行的所有可能，第二行开始的后面都是依赖于第一行翻转后的结果的",,28250,,
219,存在重复元素 II,2020/3/27,简单,常规方法,使用一个滑动窗口比较,,28805,,
643,子数组最大平均数 I,2020/4/1,简单,滑动窗口,,,29043,,
678,有效的括号字符串,2020/4/5,中等,常规方法,"个人解法：用两个计数器记录leftBracket个数和star个数，依次读取字符：
如果是'('：leftBracket加一，并修正star为min(star, leftBracket)
如果是'*'：star加一
如果是')'：若leftBracket非0，leftBracket减一；若star非0，star减一；否则返回False
遍历之后，返回leftBracket <= star",,29488,,
735,行星碰撞,2020/4/6,中等,栈,,while...else...,29362,,
344,反转字符串,2020/4/7,简单,常规方法,,,29193,,
826,安排工作以达到最大收益,2020/4/11,中等,双指针,,,29646,,
872,叶子相似的树,2020/4/19,简单,深度优先,,,29496,,
652,寻找重复的子树,2020/4/13,中等,哈希+序列化,其他解法：将每个子数哈希成一个数字，再累加这个哈希值，看是否有大于2的,"treeMap = defaultdict()
treeMap.default_factory = treeMap.__len__",30434,好题,
79,单词搜索,2020/4/21,中等,回溯递归,,,30483,,
212,单词搜索 II,2020/5/5,困难,前缀树+回溯,,,31905,,
31,下一个排列,2020/5/9,中等,递归,,,,,
32,最长有效括号,2020/5/16,困难,栈,官方解法的3，4比较好,,,,
面试题 08.09,括号,2020/5/21,中等,递归,两个计数器分别统计左括号个数和右括号个数，始终保持左>=右,,,,
301,删除无效的括号,2020/5/30,困难,BFS,先为每个字符计算一下是否不能被删（减少后面BFS的次数）和最终字符的长度L，再用BFS依次删除可能被删的字符，当字符串长度小于L，即可停止递归,,,,
856,括号的分数,2020/6/5,中等,栈,"个人解法：利用栈找到对应右括号的相对位，再用递归计算得分
官方解法：利用栈，栈的高度表示括号所在的深度，栈中的数字表示当前深度的得分",,,,
20,有效的括号,2020/6/7,简单,栈,,,,,
921,使括号有效的最少添加,2020/6/13,中等,常规方法,从前向后，统计多余的左括号数量，如果为负值，说明要添加一个左括号，最后统计多余的左括号与需要添加的左括号数量之和,,,,
224,基本计算器,2020/6/13,困难,栈,,,,,
166,分数到小数,2020/6/20,中等,常规方法,循环，模拟竖式除法,,,,
9,回文数,2020/6/20,简单,常规方法,,,,,
336,回文对,2020/6/27,困难,哈希表,官方题解对字符串反序创建哈希表，再遍历每个word的每个有效前后缀查找哈希表,,,,
98,验证二叉搜索树,2020/6/27,中等,递归,"递归计算左右子树的最小最大值，与中间的值进行比较
官方解法：中序遍历",,,,
94,二叉树的中序遍历,2020/6/28,中等,栈,,,,,
96,不同的二叉搜索树,2020/7/5,中等,动态规划,依次以1，2.。。n为顶点，计算左右子树有多少钟可能,,,,
95,不同的二叉搜索树 II,2020/7/5,中等,动态规划,"与96题类似，多出的是要构造所有节点个数为n，且val为一个范围的所有树。
例如：要构造节点个数为3的子树时，不仅要构造包含1，2，3这三个节点的子树，也要构造2，3，4/3，4，5。。。这些节点的所有子树",,,,
99,恢复二叉搜索树,2020/7/9,困难,中序遍历,,,,,
100,相同的树,2020/7/11,简单,递归,,,,,
104,二叉树的最大深度,2020/7/12,简单,递归,,,,,
105,从前序与中序遍历序列构造二叉树,2020/7/16,中等,递归,逐步拆分成子问题,,,,
106,从中序与后序遍历序列构造二叉树,2020/7/17,中等,递归,类似105,,,,
107,二叉树的层次遍历 II,2020/7/18,简单,BFS,,,,,
108,将有序数组转换为二叉搜索树,2020/7/19,简单,递归,,,,,
109,有序链表转换二叉搜索树,2020/7/21,中等,递归或中序遍历,"个人解法：转换成list，再用108题的思路
官方解法本质是： 1.计算链表的长度len 。 2.根据链表长度len用递归法创建总节点数为len的完全二叉树空间。 3.用中序遍历填入对应的数据。 第二步和第三步是同时进行的",,,,
111,二叉树的最小深度,2020/7/23,简单,递归,,,,,
112,路径总和,2020/7/25,简单,递归,,,36676,,
113,路径总和 II,2020/7/27,中等,递归,"个人解法：先构造一个相同的树，每个节点增加父节点的指针和从根节点到本节点的val之和，在构造的过程中把满足要求的path放入res中
其他解法：栈+BFS，所用空间较少",,,,
114,二叉树展开为链表,2020/8/1,中等,递归,"个人解法：
官方解法：找到左子树的最右边的节点，将右子树挂在它的右节点上",,,,
117,填充每个节点的下一个右侧节点指针 II,2020/8/3,中等,BFS,与116题类似,,,,
124,二叉树中的最大路径和,2020/8/8,困难,DFS递归,递归过程中计算以每个节点为根节点的子树中，以根节点为起点的最大路径，并计算此子树中不经过根节点的最大路径,,,,
129,求根到叶子节点数字之和,2020/8/9,中等,DFS递归,,,,,
145,二叉树的后序遍历,2020/8/9,困难,栈,"个人解法：正序栈，但性能略差，因为进出栈次数多
官方解法：反序遍历，类似中序遍历，再把结果反过来",,,,
131,分割回文串,2020/8/15,中等,递归,"个人解法：用一个全局变量保存字符串与可分的回文字串集合的映射关系，如：
d['aab'] = [[['a'],['a'],['b']], [['aa'],['b']]]",,,,
132,分割回文串 II,2020/8/22,困难,递归或动态规划,"个人解法：类似于131，能通过，但性能较差，虽然s[i:j]是否是回文的判断与官方解法次数差不多，但每次判断彼此独立，增加了复杂度
官方解法：
递推是否是回文的判断
if s[i] == s[j] and (j - i < 2 or dp[i + 1][j - 1]):
     dp[i][j] = True
min_cut[j]=min(min_cut[j],min_cut[i?1]+1)",,,,
150,逆波兰表达式求值,2020/8/23,中等,栈,,,,,
173,二叉搜索树迭代器,2020/8/29,中等,中序遍历,,,,,
164,最大间距,2020/8/30,困难,桶 + 抽屉原理,"官方解法：等间距的N-1个桶，把N个数字放入N-1个桶中，同时计算每个桶中元素的最大最小值，最大的间距会出现在桶之间
实际操作时可以设置N个桶，其中最后一个桶只放最大元素",,,,
179,最大数,2020/9/5,中等,排序,"x,y的比较转为x+y与y+x的比较","map函数可把一个list转成另一个
sorted中的参数key可定义为另一个类，在此类中实现__lt__",,,
199,二叉树的右视图,2020/9/6,中等,BFS,,,,,
222,完全二叉树的节点个数,2020/9/8,中等,DFS or 二分法,统计最底层的节点个数，可以用二分法更快,,,,
226,翻转二叉树,2020/9/12,简单,DFS,,,,,
235,二叉搜索树的最近公共祖先,2020/9/13,简单,,利用二叉搜索树的特性,,,,
236,二叉树的最近公共祖先,2020/9/13,中等,DFS,"个人解法：查找到p和q所在位置，并记录他们的父节点序列，在父节点序列中找到最后一个公共节点
官方解法：构造map保存所有节点的父节点，根据map[p]和map[q]依次向上查找，直到找到第一个相同节点",,,,
297,二叉树的序列化与反序列化,2020/9/19,困难,DFS + 先序遍历 + 栈,"个人解法使用迭代
官方解法使用递归",,,,
313,超级丑数,,中等,动态规划,与264类似,,,,
263,丑数,2020/9/25,简单,常规方法,,,,,
264,丑数II,2020/9/24,中等,动态规划,为每个素数在生成出来的丑数序列中设置一个指针，下个丑数就从每个素数*相应指针指向的丑数中取个最小的，并移动对应素数的指针到下一个位置,,,,
331,验证二叉树的前序序列化,2020/10/1,中等,栈 or 计数器,"个人解法：类似先序遍历入栈出栈，发现出栈错误时就可以终止
官方解法：不需要使用栈，只需要一个计数器，每遇到一个节点就减1，当此节点时一个数字就加2",,,,
449,序列化和反序列化二叉搜索树,2020/10/3,中等,先序遍历 or 后序遍历,"个人解法：使用栈
官方解法：使用递归","map函数产生一个新list
def serialize(self, root):
        def postorder(root):
            return postorder(root.left) + postorder(root.right) + [root.val] if root else []
        return ' '.join(map(str, postorder(root)))",,,
450,删除二叉搜索树中的节点,2020/10/4,中等,二叉搜索树,普通解法，利用搜索树的特性和树的节点操作,,,,
501,二叉搜索树中的众数,2020/10/5,简单,中序遍历,,,,,
508,出现次数最多的子树元素和,2020/10/6,中等,递归,,,,,
530,二叉搜索树的最小绝对差,2020/10/8,简单,递归或中序遍历,,,"38,260",,
538,把二叉搜索树转换为累加树,2020/10/11,中等,反序中序遍历,,,,,
543,二叉树的直径,2020/10/18,简单,DFS,,,,,
563,二叉树的坡度,2020/10/16,简单,递归,,,,,
427,建立四叉树,2020/10/24,中等,递归,,,,,
572,另一个树的子树,2020/10/25,简单,递归,,,,,
337,打家劫舍 III,2020/10/29,中等,DP + 递归,个人解法和官方解法本质相同,,,,
404,左叶子之和,2020/11/1,简单,DFS,,,,,
429,N叉树的层序遍历,2020/11/7,中等,BFS,,,,,
437,路径总和 III,2020/11/8,中等,递归,"个人解法：单递归
其他解法：双递归",,,,
559,N叉树的最大深度,2020/11/12,简单,递归,,,,,
589,N叉树的前序遍历,2020/11/13,简单,迭代 + 双向链表,,,,,
590,N叉树的后序遍历,2020/11/14,简单,迭代 + 栈,,,,,
606,根据二叉树创建字符串,2020/11/20,简单,递归 + 前序遍历,,,,,
617,合并二叉树,2020/11/21,简单,DFS,,,,,
623,在二叉树中增加一行,2020/11/22,中等,DFS,,,,,
637,二叉树的层平均值,2020/11/24,简单,BFS,,,,,
655,输出二叉树,2020/11/28,中等,DFS,,,,,
662,二叉树最大宽度,2020/11/29,中等,BFS,,,,,
669,修剪二叉搜索树,2020/12/2,简单,循环 or 递归,"个人解法：先找到一个根节点，使得此节点的val介于low和high之间，再在以它为根的子树中，裁去不在区间内的节点，代码有些长
官方解法：递归，代码简介",,,,
671,二叉树中第二小的节点,2020/12/10,简单,递归,,,,,
685,冗余连接 II,2020/12/12,困难,并查集,有几种情况：1、存在一个有向圈，2、存在一个入度为2的节点，3、同时存在1和2,,,,
687,最长同值路径,2020/12/13,中等,递归,,,,,
56,合并区间,2020/12/15,中等,排序,"intervals.sort(key=lambda x: x[0])
newInterval = sorted(intervals, key=lambda x: x[0])",,,,
57,插入区间,2020/12/17,困难,二分法,使用二分法查找新区间上下限的位置,,,,
75,颜色分类,2020/12/18,中等,partition 排序,设计好循环不变量,,,,
147,对链表进行插入排序,2020/12/20,中等,插入排序,,,,,
148,排序链表,2020/12/23,中等,归并排序,"个人解法：自顶向下
官方解法：自底向上，空间复杂度降至O(1)",,,,
220,存在重复元素 III,2020/12/24,中等,桶排序,"个人解法：二分查找，类似于二叉搜索树
官方解法：桶排序",from bintrees import avltree,,,
242,有效的字母异位词,2021/1/3,简单,哈希,利用哈希表计数，类似于桶排序,,,,
274,H 指数,2021/1/4,中等,排序,,,,,
275,H 指数 II,2021/1/5,中等,二分法,就是要找：citations是单调增的，与y = N - x这个函数（单调减的）的最左边的焦点,,,,
315,计算右侧小于当前元素的个数,2021/1/7,困难,插入排序 or 归并排序,"个人解法：插入排序
其他解法：索引数组 + 归并排序
树状数组",,,,
324,摆动排序 II,2021/1/13,中等,查找中位数,"个人解法：找到中位数后，把数列分成两组，分别在两组中选数字
其他解法：找中位数的方法可以在O(N)内完成，3-way-partition",快速选择法找中位数：在一次递归调用中，首先进行partition过程，即利用一个元素将原数组划分为两个子数组，然后将这一元素放在两个数组之间。两者区别在于快速排序接下来需要对左右两个子数组进行递归，而快速选择只需要对一侧子数组进行递归，所以快速选择的时间复杂度为O(n)。,,,
349,两个数组的交集,2021/1/15,简单,哈希表,将list转成具有Hash表性质的数据结构，再取两者的交集,,,,
350,两个数组的交集 II,2021/1/16,简单,哈希表,,,,,
452,用最少数量的箭引爆气球,2021/1/17,中等,排序+贪心算法,"个人解法：按各个气球左边界排序后，用贪心算法（此方法虽然是正确的，但不太容易直接证明，要结合官方解法更容易证明这个方式的正确）
官方解法：按各气球右边界排序，一定存在一个最优法，使得每个箭的位置都在某个气球的右边界上，再用类似个人解法的方式解决",,,,
493,翻转对,2021/1/21,困难,归并排序,"个人解法：二分法查找+插入
其他解法：归并排序 or 树状数组 (比较技巧性)",,,,
524,通过删除字母匹配到字典里最长单词,2021/1/29,中等,递归,判断一个字符串是不是另一个字符串的字串（字串出现顺序相同）,,,,
13,罗马数字转整数,2021/1/31,简单,,,,字符串,,
14,最长公共前缀,2021/1/31,简单,双重循环,,,,,
28,实现 strStr(),2021/2/4,简单,双重循环,特别解法：Rabin Karp,,,,
38,外观数列,2021/2/9,简单,双重循环,,,,,
43,字符串相乘,2021/2/13,中等,,"官方解法：用到一个小技巧，可以减少字符串操作
由于num1 和 num2 的乘积的最大长度为 m+nm+n，因此创建长度为 m+n的数组 ansArr 用于存储乘积。对于任意 0≤i<m 和0≤j<n，num1[i] * num2[j] 的结果位于 ansArr[i+j+1]，如果 ansArr[i+j+1]≥10，则将进位部分加到ansArr[i+j]。",,,,
41,缺失的第一个正数,2021/2/14,困难,,主要是要达到O(1)的空间复杂的，可以利用原数组的空间，再利用数组长度不超过300的条件，简化计算,,,,
44,通配符匹配,2021/2/16,困难,递归或动态规划,"个人解法：递归，先合并连续的*，在每次查找过程中，使用一些方法减少递归深度，如：isHaveAllSub，p.count('?') > len(s)等等
动态规划：我们用dp[i][j] 表示字符串 ss 的前 i 个字符和模式 p 的前 j 个字符是否能匹配。代码简洁，但性能较差，瓶颈在于对星号 *? 的处理方式：使用动态规划枚举所有的情况",,,,
49,字母异位词分组,2021/2/20,中等,哈希表,"个人解法：排序+哈希
官方解法：不用排序，映射到字母表的次数再哈希，这样复杂度更低一些",,,,
58,最后一个单词的长度,2021/2/21,简单,循环,,,,,
65,有效数字,2021/2/24,困难,循环,"个人解法：先按e分成两部分，两部分都可以用做判断纯数字是否正确，或者再按小数点分成两部分
状态机",,,,
67,二进制求和,2021/2/27,简单,循环,"官方解法提到一个技巧比较高的解法：
把 aa 和 bb 转换成整型数字 xx 和 yy，在接下来的过程中，xx 保存结果，yy 保存进位。
当进位不为 00 时
计算当前 xx 和 yy 的无进位相加结果：answer = x ^ y
计算当前 xx 和 yy 的进位：carry = (x & y) << 1
完成本次循环，更新 x = answer，y = carry
返回 xx 的二进制形式
为什么这个方法是可行的呢？在第一轮计算中，answer 的最后一位是 xx 和 yy 相加之后的结果，carry 的倒数第二位是 xx 和 yy 最后一位相加的进位。接着每一轮中，由于 carry 是由 xx 和 yy 按位与并且左移得到的，那么最后会补零，所以在下面计算的过程中后面的数位不受影响，而每一轮都可以得到一个低 ii 位的答案和它向低 i + 1i+1 位的进位，也就模拟了加法的过程。
class Solution:
    def addBinary(self, a, b) -> str:
        x, y = int(a, 2), int(b, 2)
        while y:
            answer = x ^ y
            carry = (x & y) << 1
            x, y = answer, carry
        return bin(x)[2:]",,,,
68,文本左右对齐,2021/3/4,困难,,,,,,
71,简化路径,2021/3/6,中等,,"个人解法：依次处理一个点，双斜杠，两个点
其他解法：按单斜杠split，再处理各个部分",,,,
72,编辑距离,2021/3/14,困难,动态规划,,"二维矩阵生成法：
dp = [[0 for _ in range(N1+1)] for _ in range(N2+1)]",,,
76,最小覆盖子串,2021/3/20,困难,滑动窗口,"个人解法：dictS 保存一个类似滑动窗口，这个窗口内其中保存t中所有字符的在s中的位置，当dictS中元素少于t中元素时，不断向dictS中增加元素，当超过t中元素时，删除下标最小的一个
官方解法，用两个下标分别指向窗口上下边界，交替向右移动上下边界，完成扫描",,,,
87,扰乱字符串,2021/3/21,困难,递归或动态规划,递归，需要保存已经计算过的结果，否则不能通过,,,,
91,解码方法,2021/3/22,中等,动态规划,,,,,
93,复原 IP 地址,2021/3/27,中等,递归 + 哈希,,,,,
97,交错字符串,2021/4/5,中等,递归 + 哈希,"个人解法：递归+哈希
官方解法：动态规划",,,,
125,验证回文串,2021/4/6,简单,双指针,,"对字符'1'之类的也能用upper()函数
isalnum()判断是否数字和字母的组合",,,
126,单词接龙 II,2021/4/10,困难,建图+DFS,每个词为一个结点，两个词距离为1，则连一条边,,,,
127,单词接龙,2021/4/15,困难,建图+DFS,建图有些技巧,"chr(ord('a') + 1) 字符和ascii码转换
x = 'abc'
list(x)
['a', 'b', 'c']",,,
151,翻转字符串里的单词,2021/4/18,中等,,"关键是要使用O(1)的空间复杂度：
将每个单词原地反转，再首位依次交换",return " ".join(reversed(s.split())),,,
214,最短回文串,2021/4/28,困难,KMP中的最长相同前后缀,比较难，KMP，next函数还没有看懂证明,,,,
227,基本计算器 II,2021/5/1,中等,队列,考虑官方解法，个人解法递归超过最大深度（递归）,"-3 // 2 == -2
int(-3/2) == -1",,,
273,整数转换英文表示,2021/5/2,困难,分治,空格的处理稍微要仔细点,,,,
345,反转字符串中的元音字母,2021/5/8,简单,双指针,,,,,
385,迷你语法分析器,2021/5/9,中等,递归 or 栈,这题使用栈的方式性能更高,,,,
387,字符串中的第一个唯一字符,2021/5/11,简单,使用哈希表存储索引,,,,,
434,字符串中的单词数,2021/5/12,简单,,,,,,
443,压缩字符串,2021/5/13,中等,双指针,,,,,
459,重复的子字符串,2021/5/16,简单,,"比较高的技巧：如果将两个 ss 连在一起，并移除第一个和最后一个字符，那么得到的字符串一定包含 ss，即 ss 是它的一个子串
或者KMP",,,,
468,验证IP地址,2021/5/27,中等,,,,,,
520,检测大写字母,2021/5/29,简单,,,"word.isupper()
word.islower()",,,
522,最长特殊序列 II,2021/6/1,中等,排序+检查每个字符串,,"自定义排序方法：
strs = sorted(strs, key=functools.cmp_to_key(cmp))",,,
537,复数乘法,2021/6/2,中等,,,,,,
539,最小时间差,2021/6/5,中等,排序,,,,,
541,反转字符串 II,2021/6/6,简单,,,,,,
551,学生出勤记录 I,2021/6/6,简单,,,,,,
553,最优除法,2021/6/9,中等,数学,"对于形如 a/b/c/d/e/f... 的表达式，答案将是 a/(b/c/d/e/f...)
除数达到最小",,,,
556,下一个更大元素 III,2021/6/12,中等,数学,,,,,
557,反转字符串中的单词 III,2021/6/13,简单,,,,,,
564,寻找最近的回文数,2021/6/14,困难,数学,"大致思路：将原字符串一分为2，取前一半，则最优解只在三个串中产生，如：
原串：""235245""，则三个串为：235532，234432，232232
再考虑下串长度是奇数偶数，以及进位退位的情况，注意""10""的特殊处理",,"37,104",,
591,标签验证器,2021/6/20,困难,状态机 + 栈,个人解法：尝试了下状态机,,,,
42,接雨水,2021/6/24,困难,DP,"个人解法：从左向右，每次计算保存（左侧）最高点的下标和高度，并将存水的低洼处填平（修改height数组）这样保证了计算过的height数组是个只有一个波峰的形状（或是完全平整的），计算下一个值时，只要考虑填平波峰和当期下标处的所有项。这个算法复杂度相当高一些
官方解法中，双指针法相对最容易理解",,,,
45,跳跃游戏 II,2021/6/30,中等,DP,"官方解法中优化了DP，记录每次计算到的最大下标的元素，可以大大减少计算次数
在此基础上的可以在优化为空间复杂度为O(1)的算法",,,,
53,最大子序和,2021/7/2,简单,,,,,,
55,跳跃游戏,2021/7/8,中等,贪心,,,,,
62,不同路径,2021/7/10,中等,DP,其他解法：从左上角到右下角的过程中，我们需要移动 m+n-2m+n?2 次，其中有 m-1m?1 次向下移动，n-1n?1 次向右移动。因此路径的总数，就等于从 m+n-2m+n?2 次移动中选择 m-1m?1 次向下移动的方案数，即组合数,,,,
63,不同路径 II,2021/7/11,中等,DP,"滚动数组思想,可以减少空间复杂度",,,,
70,爬楼梯,2021/7/13,简单,DP,其他解法：,,,,
84,柱状图中最大的矩形,2021/7/25,困难,单调栈,对于每个下标，计算以它的高度为高并且包含它的柱子的最大的矩形面积，则最大的矩形一定在这些矩形之中,,,,
85,最大矩形,2021/7/27,困难,单调栈,"利用一个技巧，再调用84题的算法
这两题是比较有技巧的，单调栈的题",,,,
118,杨辉三角,2021/7/28,简单,,,,,,
119,杨辉三角 II,2021/7/29,简单,,"其他解法：
C(m, n) = n!/(m!*(n-m)!)可以得到同一行的相邻组合数的关系
C(m, n) = C(m-1, n) * (n - m + 1) / m
由组合数公式 ，利用上述公式我们可以在线性时间计算出第 nn 行的所有组合数。",,,,
120,三角形最小路径和,2021/7/30,中等,DP,,,,,
121,买卖股票的最佳时机,2021/7/31,简单,,,,,,
122,买卖股票的最佳时机 II,2021/8/1,简单,贪心算法,,,,,
123,买卖股票的最佳时机 III,2021/8/4,困难,DP,,,,,
139,单词拆分,2021/8/7,中等,DFS+哈希，DP,"个人解法：DFS+哈希，空间复杂度有点高
其他解法：DP，空间 O(0)","缓存机制，
from functools import lru_cache
@functools.lru_cache(None)
这样不需要自己手写哈希字典了",,,
140,单词拆分 II,2021/8/10,困难,DFS+哈希,类似139,,,,
152,乘积最大子数组,2021/8/11,中等,DP,使用两个dp数组，协作得到递推公式,,,,
174,地下城游戏,2021/8/14,困难,DP,官方解法：倒过来思考,比较有代表性的反向思考的DP问题,,,
188,买卖股票的最佳时机 IV,2021/8/15,困难,DP,与123类似,,,,
221,最大正方形,2021/8/17,中等,DP,,,"36,634",,
233,数字 1 的个数,2021/8/20,困难,数学计算,"个人解法：比如2345，先计算小于1000的数中1的个数，再算[1000,2000)的，再算[2000,2300),再算[2300,2340),[2340,2345]的，每段之中都有固定的公式，或是具体的值

官方解法：举个例子： n = 2304 。答案为四个部分之和：
1. 所有小于等于2304的正整数中，个位出现1的次数.
2. 所有小于等于2304的正整数中，十位出现1的次数.
3. 所有小于等于2304的正整数中，百位出现1的次数.
4. 所有小于等于2304的正整数中，千位出现1的次数.

",,,,
309,最佳买卖股票时机含冷冻期,2021/8/28,中等,DP,,,,,
312,戳气球,2021/9/1,困难,DP 或 分治,"分治就是递归，DP就是把分治倒过来实现，DP的性能高一点，但代码复杂一些
这题还是比较难的，是一个需要倒过来考虑的题目",,,,
329,矩阵中的最长递增路径,2021/9/11,困难,递归,,"二维数组中最大值的获取：
max(map(max, dp))",,,
354,俄罗斯套娃信封问题,2021/9/17,困难,LIS,比较有技巧，需要用题300的LIS算法，假如每种宽度的信封最多只有一种，那么按宽度排序之后，可以直接用LIS算法；假如有相同的宽度的信封，那么就要先对相同宽度的信封按长度排序，而且是放过来排序，这样用LIS时，可以保证没有宽度最多只会选到一个。,"按两个维度排序：
envelopes.sort(key=lambda x: (x[0], -x[1]))
时间函数：
import time
start = time.time()
now = time.time()
print(now - start)",,,
357,计算各个位数不同的数字个数,2021/9/21,中等,排列组合 + DP,,,,,
368,最大整除子集,2021/9/24,中等,DP,DP数组表示最大元素为nums[i]的子集的最大元素个数，有点类似题300,,,,
375,猜数字大小 II,2021/9/25,中等,递归 + 遍历,分治法去循环递归,,,,
376,摆动序列,2021/9/26,中等,贪心算法,数有几个单调区间，连续几个相同单调性的区间算一个,,,,
377,组合总和 Ⅳ,2021/10/4,中等,递归 or DP,分治递归或是反过来思考就是DP,,,,
392,判断子序列,2021/10/5,简单,双指针 or DP,"官方解法中提出DP： 令 f[i][j]f[i][j] 表示字符串 tt 中从位置 ii 开始往后字符 jj 第一次出现的位置。在进行状态转移时，如果 tt 中位置 ii 的字符就是 jj，那么 f[i][j]=if[i][j]=i，否则 jj 出现在位置 i+1i+1 开始往后，即 f[i][j]=f[i+1][j]f[i][j]=f[i+1][j]，因此我们要倒过来进行动态规划，从后往前枚举 ii。
这样可以解决有大量s的处理场景",,37928,,
396,旋转函数,2021/10/7,中等,递推公式,F(k) = F(k - 1) + (sum - N * num[N - k]),,,,
397,整数替换,2021/10/13,中等,位运算 + 数学技巧,除以2就是左移一位,,,,
403,青蛙过河,2021/10/14,困难,递推,官方解法中的DP，是个思路，就是有点复杂了,,,,
410,分割数组的最大值,2021/10/25,困难,二分法,"二分法是一个比较技巧的方法
DP的方法会超时，以D[(j, k)]表示 nums[0]到nums[j] 分隔 k段的最小值",,,,
413,等差数列划分,2021/10/26,中等,DP,,,,,
435,无重叠区间,2021/10/27,中等,贪心算法,"题目的要求等价于「选出最多数量的区间，使得它们互不重叠」
这题有一定技巧，DP的方式会超时
按区间右值先找到最小的那个，再在剩下与第一个没有交集的区间中找个区间右值最小的那个，依次下去",,,,
446,等差数列划分 II - 子序列,2021/10/29,困难,DP,想了比较长时间，开始就考虑DP，但想的有点复杂了，最后的方法还是比较简洁的,,,,
458,可怜的小猪,2021/11/16,困难,数学推导,数学推导的技巧有点难,,,,
464,我能赢吗,2021/11/19,中等,递归,没有数学上技巧的方法，需要递归，要用的技巧是把为选过的数与2进制数的映射，再考虑递归的思路，当前状态是否能稳赢相当与，先手可以到达，或者先手走了某一步之后（注意这里只需要某一步，而不是所有步），后手无法赢,,,,
466,统计重复个数,2021/11/30,困难,数学技巧,推导出循环周期,,,,
472,连接词,2021/12/5,困难,递归,"带过滤的递归，如果直接递归，性能不够，可以把连接词和非连接词分别放在两个set中进行判断，减少递归次数
其他解法：字典树(trie表)",,,,
473,火柴拼正方形,2021/12/12,中等,递归,"个人解法：统计各个长度的个数，并排序，生成新的结构，依据这个结构依次去选择和为每条边长的火柴，尽量避免重复计算
官方解法的性能要更好一些，通过二进制表示选过的火柴+完成的边数作为哈希key",,,,
474,一和零,2021/12/18,中等,递归,"个人解法：先按0的个数排序，0个个数相同的按1的个数排序，然后递归选择，选择时，注意因为排过序，所以如何0的个数相同的字符串，前面的如果不被选择，后面的一定不能选择，这样可以减少一些递归的次数
官方解法：动态规划，类似背包问题",,,,
486,预测赢家,2021/12/24,中等,递归 + 哈希,"个人解法：递归 + 哈希
官方解法：DP，dp[i][j] 表示当数组剩下的部分为下标 ii 到下标 jj 时，即在下标范围 [i, j][i,j] 中，当前玩家与另一个玩家的分数之差的最大值，注意当前玩家不一定是先手
官方解法性能应该更好",,,,
488,祖玛游戏,2021/12/26,困难,递归,需要带剪枝的递归，排除一些情况，否则性能不够,,,,
1609,奇偶树,2021/12/25,中等,BFS,"from collections import deque
queue = deque()",,,,
825,适龄的朋友,2021/12/27,中等,二分法,"个人解法：二分法
官方解法：双指针，性能更高",,,,
494,目标和,2021/12/29,中等,DP,反过来的执行DP,,,,
472,连接词,2021/12/28,困难,递归 + 哈希,,,,,
846,一手顺子,2021/12/30,中等,贪心算法,,,,,
507,完美数,2021/12/31,简单,循环,,,,,
514,自由之路,2022/1/3,困难,DP,"个人解法：倒序生成DP数组，效果和顺序相同，会多一些没用的计算，唯一可能的好处是，可以获取从任意位置开始的最小路径
官方解法：顺序生成DP","最大数写法：float('inf')
默认字典值的另一种写法：
            for i, e in enumerate(ring):
                dic[e] = dic.get(e, [])
                dic[e].append(i)",37880,,
2022,将一维数组转变成二维数组,2022/1/1,简单,循环,,,,,
390,消除游戏,2022/1/3,中等,递推公式,,,,,
516,最长回文子序列,2022/1/5,中等,DP,个人解法：用了两个DP数组，也能通过，但是有点多余,,,,
1614,括号的最大嵌套深度,2022/1/7,简单,栈,,,,,
518,零钱兑换 II,2022/1/8,中等,DP,"个人解法：使用了二位的DP数组，其中会有很多重复的计算，能通过，但性能较差
官方解法：一位数组搞定",,,,
526,优美的排列,2022/1/14,中等,DP,,,,,
1629,按键持续时间最长的键,2022/1/9,简单,一次循环,,,,,
35,搜索插入位置,2022/1/11,简单,二分法,,,,,
747,至少是其他数字两倍的最大数,2022/1/13,简单,循环,,,,,
1716,计算力扣银行的钱,2022/1/15,简单,等差数列,,,,,
382,链表随机节点,2022/1/16,中等,循环,"官方解法：水塘抽样
从链表头开始，遍历整个链表，对遍历到的第 ii 个节点，随机选择区间 [0,i)[0,i) 内的一个整数，如果其等于 00，则将答案置为该节点值，否则答案不变。",,,,
542,01 矩阵,2022/1/17,中等,DP,"个人解法：多次递推，每次挑选下一轮需要更新的节点，但性能不如官方解法，更新的次数可能比较多
官方解法：
只有 水平向左移动 和 竖直向上移动；
只有 水平向右移动 和 竖直向下移动。
可以这样理解，从最近的0走到1，肯定只能从1周围上下左右4个点走到1，第一次从左上角到右下角遍历整个表，到表中任意位置i的时候，i上方和左方的位置已经遍历过了，所以可以判断从上方进入这个1和左方进入这个1的状况哪个最近，并在dp数组保存。同理，第二次从右下角到左上角遍历整个表到i位置时，i右方和下方的位置状态已经更新过了，所以能判断从右边进入合算还是从下边进入合算，再加上第一次遍历保存的左方和上方的最优解就能判断出上下左右四个方向的最优解了",,,,
219,存在重复元素 II,2022/1/19,简单,循环,,,,,
21,合并两个有序链表,2022/1/20,简单,双指针,,,,,
24,两两交换链表中的节点,2022/1/22,中等,链表,,,,,
2034,股票价格波动,2022/1/23,中等,,,,,,
26, 删除有序数组中的重复项,2022/1/24,简单,循环,,,,,
1688,比赛中的配对次数,2022/1/25,简单,数学推导,,,,,
33,搜索旋转排序数组,2022/1/26,中等,二分法,,,,,
2047,句子中的有效单词数,2022/1/27,简单,,,,,,
1996,游戏中弱角色的数量,2022/1/29,中等,排序+数学技巧,"双指标的排序
单调栈",,,,
884,两句话中的不常见单词,2022/1/30,简单,哈希,,,,,
,,2022/1/31,,,,"from collections import Counter
Counter(s1.split())",,,
,,2022/2/1,,,,,,,
,,2022/2/2,,,,,,,
,,2022/2/3,,,,,,,
,,2022/2/4,,,,,,,
,,2022/2/5,,,,,,,
1748,唯一元素的和,2022/2/6,简单,哈希,,"sum(num for num, cnt in Counter(nums).items() if cnt == 1)",,,
1405,最长快乐字符串,2022/2/7,中等,,,,,,
1001,网格照明,2022/2/8,困难,哈希表,技巧性比较高,,,,
2006,差的绝对值为 K 的数对数目,2022/2/9,简单,哈希,Counter,,33158,,
1447,最简分数,2022/2/10,中等,代数,gcd最大公约数,,,,
,,2022/2/11,,,,,,,
1020,飞地的数量,2022/2/12,中等,哈希,,,,,
1189,“气球” 的最大数量,2022/2/13,简单,统计,,,,,
540,有序数组中的单一元素,2022/2/14,中等,二分法,按位异或运算符,,,,
,,2022/2/15,,,,,,,
,,2022/2/16,,,,,,,
688,骑士在棋盘上的概率,2022/2/17,中等,递归 or DP,,,,,
1791,找出星型图的中心节点,2022/2/18,简单,,,,,,
969,煎饼排序,2022/2/19,中等,数学,,,,,
717,1比特与2比特字符,2022/2/20,简单,,官方解法的倒序遍历：利用了 “0 一定是一个字符的结尾” 这个条件,,,,
838,推多米诺,2022/2/21,中等,,,,,,
1994,好子集的数目,,困难,DP,,很难,,,
917,仅仅反转字母,2022/2/23,简单,双指针,,,,,
1706,球会落何处,2022/2/24,中等,模拟,,,,,
2016,增量元素之间的最大差值,2022/2/25,简单,,,,,,
258,各位相加,2022/3/3,简单,,进阶：数根,,,,
2104,子数组范围和,2022/3/4,中等,单调栈,,,,,
2100,适合打劫银行的日子,,中等,,,,,,
504,七进制数,2022/3/7,简单,取模,,,,,
2055,蜡烛之间的盘子,2022/3/8,中等,前缀和,,,,,
798,得分最高的最小轮调,2022/3/10,困难,差分数组,比较典型的差分数组,,,,
2049,统计最高分的节点数目,2022/3/11,中等,,,,,,
393,UTF-8 编码验证,2022/3/13,中等,,,,,,
599,两个列表的最小索引总和,2022/3/14,简单,哈希,,,,,
2044,统计按位或能得到最大值的子集数目,2022/3/15,中等,DFS+哈希,,,,,
432,全 O(1) 的数据结构,,困难,,,,,,
720,词典中最长的单词,2022/3/17,简单,,,,,,
2043,简易银行系统,2022/3/18,中等,数组,,,,,
2039,网络空闲的时刻,,简单,,,,,,
2038,如果相邻两个颜色均相同则删除当前颜色,2022/3/22,中等,,,,,,
440,字典序的第K小数字,,困难,,,,,,
661,图片平滑器,2022/3/24,简单,,,,,,
682,棒球比赛,2022/3/26,简单,模拟,,,,,
2028,找出缺失的观测数据,2022/3/27,中等,递归 + 模拟,官方解法直接模拟，更简洁,,,,
693,交替位二进制数,2022/3/28,简单,位运算 + 数学技巧,"a = n ^ (n >> 1)
return a & (a + 1) == 0",,,,
2024,考试的最大困扰度,2022/3/30,中等,滑动窗口,双指针,,,,
1606,找到处理最多请求的服务器,,困难,,,,,,
954,二倍数对数组,2022/4/1,中等,二分法,官方解法：哈希更快,,,,
420,强密码检验器,,困难,,,,,,
2215,找出两数组的不同,2022/3/27,简单,,,,,,
2216,美化数组的最少删除数,2022/3/27,中等,,,,,,
2217,找到指定长度的回文数,2022/3/27,中等,,,,,,
744,寻找比目标字母大的最小字母,2022/4/4,简单,,,,,,
307,区域和检索 - 数组可修改,,中等,,,,,,
762,二进制表示中质数个计算置位,2022/4/5,简单,,,"二进制数中1的个数：
n & (n - 1)，其运算结果恰为把 n的二进制位中的最低位的 1 变为 0 之后的结果。",,,
796,旋转字符串,2022/4/7,简单,字符串,官方解法：只需要检查 goal 是否为 s + s 的子字符串即可,,27525,,13311
780,到达终点,2022/4/9,困难,数学求余 + 反向思维,,,,,
806,写字符串需要的行数,2022/4/12,简单,,,,,,
380,O(1) 时间插入、删除和获取随机元素,2022/4/13,中等,,,"1、choice() 函数

print (""从 range(100) 返回一个随机数 : "",random.choice(range(100)))
print (""从列表中 [1, 2, 3, 5, 9]) 返回一个随机元素 : "", random.choice([1, 2, 3, 5, 9]))
print (""从字符串中 'Runoob' 返回一个随机字符 : "", random.choice('Runoob'))",,,
1672,最富有客户的资产总量,2022/4/14,简单,,,"map(sum, accounts)",,,
479,最大回文数乘积,2022/4/16,困难,枚举法,,,,,
2231,按奇偶性交换后的最大数字,2022/4/10,简单,,,,,,
2232,向表达式添加括号后的最小结果,2022/4/10,中等,,,,,,
,找到最接近 0 的数字,2022/4/16,简单,,,,,,
,买钢笔和铅笔的方案数,2022/4/16,中等,,,,,,
,设计一个 ATM 机器,2022/4/16,中等,,,,,,
819,最常见的单词,2022/4/17,简单,,,,,,
2243,计算字符串的数字和,2022/4/17,简单,,,,,,
2244,完成所有任务需要的最少轮数,2022/4/17,中等,,,,,,
2246,相邻字符不同的最长路径,2022/4/17,困难,,,,,,
386,字典序排数,2022/4/19,中等,,,,,,
821,字符的最短距离,2022/4/19,简单,,,,,,
388,文件的最长绝对路径,2022/4/20,中等,栈,,,,,
824,山羊拉丁文,2022/4/21,简单,,,,,,
587,安装栅栏,2022/5/3,困难,数学,计算区域顶点开始的斜率,,,,
868,二进制间距,2022/4/24,简单,,,,,,
398,随机数索引,2022/4/25,中等,,高阶：水塘抽样,,,,
883,三维形体投影面积,2022/4/26,简单,,map函数用法,,,,
417,太平洋大西洋水流问题,2022/4/27,中等,,,,,,
905,按奇偶排序数组,2022/4/28,简单,,,,,,
908,最小差值 I,2022/4/30,简单,,,,,,
2255,统计是给定字符串前缀的字符串数目,2022/4/30,简单,,,,,,
2256,最小平均差,2022/4/30,中等,,,,,,
2257,统计网格图中没有被保卫的格子数,2022/4/30,中等,,,,,,
1305,两棵二叉搜索树中的所有元素,2022/5/1,中等,中序遍历,,,,,
2262,字符串的总引力,2022/5/2,困难,DP,,,,,
2259,移除指定数字得到的最大结果,2022/5/1,简单,,,,,,
2260,必须拿起的最小连续卡牌数,2022/5/1,中等,,,,,,
2261,含最多 K 个可整除元素的子数组,2022/5/1,中等,,,,,,
2258,逃离火灾,2022/5/1,困难,DP,,,,,
937,重新排列日志文件,2022/5/3,简单,,,,,,
1823,找出游戏的获胜者,2022/5/4,中等,,,,,,
713,乘积小于 K 的子数组,2022/5/5,中等,滑动窗口,滑动窗口的题目,,,,
933,最近的请求次数,2022/5/6,简单,,考虑用 deque(),,,,
433,最小基因变化,2022/5/7,中等,BFS,,,,,
2264,字符串中最大的 3 位相同数字,2022/5/8,简单,,,,,,
2265,统计值等于子树平均值的节点数,2022/5/8,中等,,,,,,
2266,统计打字方案数,2022/5/8,中等,,,,,,
2267,检查是否有合法括号字符串路径,2022/5/8,困难,,,,,,
942,增减字符串匹配,2022/5/9,简单,双指针 或 deque,,,,,
1728,猫和老鼠 II,,极其困难,,,,,,
,,,,,,,,,
面试题 01.05.,一次编辑,2022/5/13,中等,,,,,,
691,贴纸拼词,,困难,,,,,,
2269,找到一个数字的 K 美丽值,2022/5/14,简单,,,,,,
2270,分割数组的方案数,2022/5/14,中等,,,,,,
2271,毯子覆盖的最多白色砖块数,2022/5/15,中等,滑动窗口,,,,,
812,最大三角形面积,2022/5/15,简单,几何公式,,,,,
面试题 04.06.,后继者,2022/5/16,中等,BFS,,,,,
2276,统计区间中的整数数目,2022/5/17,困难,区间并集,,,,,
668,乘法表中第k小的数,2022/5/18,困难,数学求和+二分法,"涉及元素极多做不到遍历的二维矩阵里的第K小都可以用二分猜答案的套路
个人解法，也用了二分，有些复杂",,,,
436,寻找右区间,2022/5/20,中等,二分法，双指针,官方解法的双指针效率更高,,,,
961,在长度 2N 的数组中找出重复 N 次的元素,2022/5/21,简单,哈希表,官方解法中，随机选择的概率法比较好,random.randrange(n),,,
2273,移除字母异位词后的结果数组,2022/5/15,简单,,,,,,
2274,不含特殊楼层的最大连续楼层数,2022/5/15,中等,,,,,,
2275,按位与结果大于零的最长组合,2022/5/15,中等,按位操作,,,,,
2272,最大波动的子字符串,,困难,枚举+DP,难道比较大，要用DP去计算最大字串和,,,,
2278,字母在字符串中的百分比,2022/5/22,简单,,,,,,
2279,装满石头的背包的最大数量,2022/5/22,中等,,,,,,
2280,表示一个折线图的最少线段数,2022/5/22,中等,,,,,,
2281,巫师的总力量和,,困难,,,,21124,,
675,为高尔夫比赛砍树,,困难,,,,,,
965,单值二叉树,2022/5/24,简单,DFS,,,,,
699,掉落的方块,2022/5/27,困难,区间合并,,,,,
面试题 17.11. ,单词距离,2022/5/27,中等,哈希 + 双指针,,,,,
1021,删除最外层的括号,2022/5/28,简单,栈,,,,,
2283,判断一个数的数字计数是否等于数位的值,2022/5/28,简单,,,,,,
2284,最多单词数的发件人,2022/5/28,中等,,,,,,
2285,道路的最大总重要性,2022/5/28,中等,,,,,,
2286,以组为单位订音乐会的门票,,困难,,,,,,
2287,重排字符形成目标字符串,2022/5/29,简单,,,,,,
2288,价格减免,2022/5/29,中等,,,,,,
2289,使数组按非递减顺序排列,,中等,,,,,,
2290,到达角落需要移除障碍物的最小数目,2022/5/29,困难,,,,,,
1022,从根到叶的二进制数之和,2022/5/30,简单,DFS,,,,,
剑指 Offer II 114,外星文字典,,困难,单调栈,单调栈的小变形,,,,
829,连续整数求和,2022/6/3,困难,数学等差数列,,,,,
929,独特的电子邮件地址,2022/6/4,简单,字符串,,"local = email[:i].split('+', 1)[0]  # 去掉本地名第一个加号之后的部分
            local = local.replace('.', '')  # 去掉本地名中所有的句点",,,
478,在圆内随机生成点,2022/6/5,中等,随机数,"拒绝采样法，更为简单
否则要注意随机变量的取值","random.uniform(a, b)，用于生成一个指定范围内的随机符点数，两个参数其中一个是上限，一个是下限。如果a > b，则生成的随机数n: a <= n <= b。如果 a <b， 则 b <= n <= a。
（random.uniform()可以允许下限大于上限，不会报错，随机结果在a和b之间，可以等于上下限）",,,
2293,极大极小游戏,2022/6/5,简单,,,,,,
2294,划分数组使最大差为 K,2022/6/5,中等,,,,,,
2295,替换数组中的元素,2022/6/5,中等,,,,,,
2296,设计一个文本编辑器,2022/6/5,困难,,,,,,
732,我的日程安排表 III,2022/6/6,困难,差分数组 or 线段树,待研究，个人解法：区间合并,,,,
875,爱吃香蕉的珂珂,2022/6/7,中等,二分法,,bisect_left增加了key参数,,,
1037,有效的回旋镖,2022/6/8,简单,,,,,,
497,非重叠矩形中的随机点,2022/6/9,中等,随机数,,,,,
730,统计不同回文子序列,,困难,,,,,,
926,将字符串翻转到单调递增,2022/6/11,中等,DP,,,,,
890,查找和替换模式,2022/6/12,中等,映射,,,,,
1051,高度检查器,2022/6/13,简单,排序,可以考虑使用计数排序,,,,
498,对角线遍历,2022/6/14,中等,,,,,,
719,找出第 K 小的数对距离,2022/6/16,困难,二分法,隐藏二分法的例子,,,,
532,数组中的 k-diff 数对,2022/6/16,中等,哈希,个人解法：二分法，不如哈希的性能,,,,
1089,复写零,2022/6/17,简单,字符串,,,18867,,
剑指 Offer II 029,排序的循环链表,2022/6/18,中等,链表操作,,,,,
,兼具大小写的最好英文字母,2022/6/19,简单,,,,,,
,个位数字为 K 的整数之和,2022/6/19,中等,,,,,,
,小于等于 K 的最长二进制子序列,2022/6/19,中等,,,,,,
,卖木头块,2022/6/19,困难,,,,,,
715,Range 模块,,困难,线段树,,,,,
1108,IP 地址无效化,2022/6/21,简单,,,,,,
剑指 Offer II 091,粉刷房子,2022/6/25,中等,DP,,,,,
,统计星号,2022/6/25,简单,,,,,,
,统计无向图中无法互相到达点对数,2022/6/26,困难,DFS,"可以用DFS快速计算出每棵树的大小
个人解法想到并查集，但没有算出来，还有再看看",,,,
,操作后的最大异或和,2022/6/26,中等,数学,,"from functools import reduce
reduce(function, iterable[, initializer])",,,
,判断矩阵是否是一个 X 矩阵,2022/6/26,简单,,,,,,
,统计放置房子的方式数,2022/6/26,中等,DP,,,,,
,拼接数组的最大分数,2022/6/26,中等,DP,,,,,
710,黑名单中的随机数,2022/6/26,困难,数学,,"dict.get(key[, value]) 指定默认值
返回指定键的值，如果键不在字典中返回默认值 None 或者设置的默认值。",,,
535,TinyURL 的加密与解密,2022/6/29,中等,,,,,,
1175,质数排列,2022/6/30,简单,排列组合,,,17557,2184,5462
871,最低加油次数,2022/7/2,困难,贪心算法,,heappush heappop方法，可以构建小顶堆,,,
