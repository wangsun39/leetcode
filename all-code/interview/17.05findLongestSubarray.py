# 给定一个放有字母和数字的数组，找到最长的子数组，且包含的字母和数字的个数相同。
#
# 返回该子数组，若存在多个最长子数组，返回左端点下标值最小的子数组。若不存在这样的数组，返回一个空数组。
#
# 示例 1:
#
# 输入: ["A","1","B","C","D","2","3","4","E","5","F","G","6","7","H","I","J","K","L","M"]
#
# 输出: ["A","1","B","C","D","2","3","4","E","5","F","G","6","7"]
# 示例 2:
#
# 输入: ["A","A"]
#
# 输出: []
# 提示：
#
# array.length <= 100000

from typing import List

class Solution:
    def findLongestSubarray(self, array: List[str]) -> List[str]:
        d = {0: 0}  # d[i] = x 表示 数字比字母多 i 的最小下标为 x
        ans = 0
        begin = 0
        s = 0  # 当前 数字比字母多的个数
        for i, x in enumerate(array):
            if x.isdigit():
                s += 1
            else:
                s -= 1
            # print(i,x,s)
            if s in d:
                if ans < i - d[s]:
                    ans = i - d[s]
                    begin = d[s]
            if s not in d:
                d[s] = i + 1
        # print(d)
        if ans > 0:
            return array[begin: begin + ans + 1]
        return []




so = Solution()
print(so.findLongestSubarray(["A","1","B","C","D","2","3","4","E","5","F","G","6","7","H","I","J","K","L","M"]))
print(so.findLongestSubarray(["42","10","O","t","y","p","g","B","96","H","5","v","P","52","25","96","b","L","Y","z","d","52","3","v","71","J","A","0","v","51","E","k","H","96","21","W","59","I","V","s","59","w","X","33","29","H","32","51","f","i","58","56","66","90","F","10","93","53","85","28","78","d","67","81","T","K","S","l","L","Z","j","5","R","b","44","R","h","B","30","63","z","75","60","m","61","a","5","S","Z","D","2","A","W","k","84","44","96","96","y","M"]))
print(so.findLongestSubarray(["A","A"]))

x = ["52","3","v","71","J","A","0","v","51","E","k","H","96","21","W","59","I","V","s","59","w","X","33","29","H","32","51","f","i","58","56","66","90","F","10","93","53","85","28","78","d","67","81","T","K","S","l","L","Z","j","5","R","b","44","R","h","B","30","63","z","75","60","m","61","a","5"]
c1 = c2 = 0
for i in x:
    if i.isdigit():
        c1 += 1
    else:
        c2 += 1
print(c1, c2)



