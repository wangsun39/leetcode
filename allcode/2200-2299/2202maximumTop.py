# 给你一个下标从 0 开始的整数数组 nums ，它表示一个 堆 ，其中 nums[0] 是堆顶的元素。
#
# 每一次操作中，你可以执行以下操作 之一 ：
#
# 如果堆非空，那么 删除 堆顶端的元素。
# 如果存在 1 个或者多个被删除的元素，你可以从它们中选择任何一个，添加 回堆顶，这个元素成为新的堆顶元素。
# 同时给你一个整数 k ，它表示你总共需要执行操作的次数。
#
# 请你返回 恰好 执行 k 次操作以后，堆顶元素的 最大值 。如果执行完 k 次操作以后，堆一定为空，请你返回 -1 。
#
#
#
# 示例 1：
#
# 输入：nums = [5,2,2,4,0,6], k = 4
# 输出：5
# 解释：
# 4 次操作后，堆顶元素为 5 的方法之一为：
# - 第 1 次操作：删除堆顶元素 5 ，堆变为 [2,2,4,0,6] 。
# - 第 2 次操作：删除堆顶元素 2 ，堆变为 [2,4,0,6] 。
# - 第 3 次操作：删除堆顶元素 2 ，堆变为 [4,0,6] 。
# - 第 4 次操作：将 5 添加回堆顶，堆变为 [5,4,0,6] 。
# 注意，这不是最后堆顶元素为 5 的唯一方式。但可以证明，4 次操作以后 5 是能得到的最大堆顶元素。
# 示例 2：
#
# 输入：nums = [2], k = 1
# 输出：-1
# 解释：
# 第 1 次操作中，我们唯一的选择是将堆顶元素弹出堆。
# 由于 1 次操作后无法得到一个非空的堆，所以我们返回 -1 。
#
#
# 提示：
#
# 1 <= nums.length <= 105
# 0 <= nums[i], k <= 109

from leetcode.allcode.competition.mypackage import *

class Solution:
    def maximumTop(self, nums: List[int], k: int) -> int:
        n = len(nums)
        if n == 1:
            if k & 1: return -1
            return nums[0]
        if k <= 1: return nums[k]
        if k <= n - 1:
            return max(max(nums[:k - 1]), nums[k])
        if k > n:
            return max(nums)
        return max(nums[:k - 1])



so = Solution()
print(so.maximumTop([91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99], 1))
print(so.maximumTop([91,98,17,79,15,55,47,86,4,5,17,79,68,60,60,31,72,85,25,77,8,78,40,96,76,69,95,2,42,87,48,72,45,25,40,60,21,91,32,79,2,87,80,97,82,94,69,43,18,19,21,36,44,81,99], 2))
print(so.maximumTop([35,43,23,86,23,45,84,2,18,83,79,28,54,81,12,94,14,0,0,29,94,12,13,1,48,85,22,95,24,5,73,10,96,97,72,41,52,1,91,3,20,22,41,98,70,20,52,48,91,84,16,30,27,35,69,33,67,18,4,53,86,78,26,83,13,96,29,15,34,80,16,49], 15))




