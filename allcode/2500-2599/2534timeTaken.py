# n 个人，按从 0 到 n - 1 编号。现在有一扇门，每个人只能通过门进入或离开一次，耗时一秒。
#
# 给你一个 非递减顺序 排列的整数数组 arrival ，数组长度为 n ，其中 arrival[i] 是第 i 个人到达门前的时间。另给你一个长度为 n 的数组 state ，其中 state[i] 是 0 则表示第 i 个人希望进入这扇门，是 1 则表示 TA 想要离开这扇门。
#
# 如果 同时 有两个或更多人想要使用这扇门，则必须遵循以下规则：
#
# 如果前一秒 没有 使用门，那么想要 离开 的人会先离开。
# 如果前一秒使用门 进入 ，那么想要 进入 的人会先进入。
# 如果前一秒使用门 离开 ，那么想要 离开 的人会先离开。
# 如果多个人都想朝同一方向走（都进入或都离开），编号最小的人会先通过门。
# 返回一个长度为 n 的数组 answer ，其中 answer[i] 是第 i 个人通过门的时刻（秒）。
#
# 注意：
# 每秒只有一个人可以通过门。
# 为遵循上述规则，一个人可以在到达门附近后等待，而不通过门进入或离开。
#
#
# 示例 1：
#
# 输入：arrival = [0,1,1,2,4], state = [0,1,0,0,1]
# 输出：[0,3,1,2,4]
# 解释：每秒发生的情况如下：
# - t = 0 ：第 0 个人是唯一一个想要进入的人，所以 TA 可以直接进入。
# - t = 1 ：第 1 个人想要离开，第 2 个人想要进入。因为前一秒有人使用门进入，所以第 2 个人先进入。
# - t = 2 ：第 1 个人还是想要离开，第 3 个人想要进入。因为前一秒有人使用门进入，所以第 3 个人先进入。
# - t = 3 ：第 1 个人是唯一一个想要离开的人，所以 TA 可以直接离开。
# - t = 4 ：第 4 个人是唯一一个想要进入的人，所以 TA 可以直接离开。
# 示例 2：
#
# 输入：arrival = [0,0,0], state = [1,0,1]
# 输出：[0,2,1]
# 解释：每秒发生的情况如下：
# - t = 0 ：第 1 个人想要进入，但是第 0 个人和第 2 个人都想要离开。因为前一秒没有使用门，所以想要离开的人会先离开。又因为第 0 个人的编号更小，所以 TA 先离开。
# - t = 1 ：第 1 个人想要进入，第 2 个人想要离开。因为前一秒有人使用门离开，所以第 2 个人先离开。
# - t = 2 ：第 1 个人是唯一一个想要进入的人，所以 TA 可以直接进入。
#
#
# 提示：
#
# n == arrival.length == state.length
# 1 <= n <= 105
# 0 <= arrival[i] <= n
# arrival 按 非递减顺序 排列
# state[i] 为 0 或 1

from leetcode.allcode.competition.mypackage import *

class Solution:
    def timeTaken(self, arrival: List[int], state: List[int]) -> List[int]:
        cur = 0
        pre = 0   # 0: 表示上一秒没有使用门， 1: 表示上一秒进入， -1: 表示上一秒离开
        n = len(arrival)
        i = 0
        ans = [0] * n
        inq = deque()  # 进门队列
        deq = deque()  # 出门队列
        while i < n or inq or deq:
            while i < n and arrival[i] <= cur:
                if state[i] == 0:
                    inq.append(i)
                else:
                    deq.append(i)
                i += 1
            if not inq and not deq:
                if cur < arrival[i]:
                    pre = 0
                cur = arrival[i]
                continue
            if pre in (0, -1):
                if deq:
                    x = deq.popleft()
                    pre = -1
                else:
                    x = inq.popleft()
                    pre = 1
            else:
                if inq:
                    x = inq.popleft()
                    pre = 1
                else:
                    x = deq.popleft()
                    pre = -1
            ans[x] = cur
            cur += 1
        return ans


so = Solution()
print(so.timeTaken(arrival = [1,1,2,3,10,11,12,43,43,71,72,73,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75,75],
                   state = [0,1,1,1,0,1,1,1,1,0,1,0,1,0,1,1,1,1,0,0,1,0,1,1,0,1,1,1,1,1,0,1,1,1,1,1,1,0,0,0,0,0,1,0,0,1,0,0,1,0,1,0,1,1,0,1,0,1,1,0,1,0,0,0,0,1,0,0,1,1,1,1,1,0,0]))
print(so.timeTaken(arrival = [0,1,1,2,4], state = [0,1,0,0,1]))  # [0,3,1,2,4]
print(so.timeTaken(arrival = [0,0,0], state = [1,0,1]))  # [0,2,1]




