# 给你一个整数 n 和一个下标从 0 开始的整数数组 sick ，数组按 升序 排序。
#
# 有 n 位小朋友站成一排，按顺序编号为 0 到 n - 1 。数组 sick 包含一开始得了感冒的小朋友的位置。如果位置为 i 的小朋友得了感冒，他会传染给下标为 i - 1 或者 i + 1 的小朋友，前提 是被传染的小朋友存在且还没有得感冒。每一秒中， 至多一位 还没感冒的小朋友会被传染。
#
# 经过有限的秒数后，队列中所有小朋友都会感冒。感冒序列 指的是 所有 一开始没有感冒的小朋友最后得感冒的顺序序列。请你返回所有感冒序列的数目。
#
# 由于答案可能很大，请你将答案对 109 + 7 取余后返回。
#
# 注意，感冒序列 不 包含一开始就得了感冒的小朋友的下标。
#
#
#
# 示例 1：
#
# 输入：n = 5, sick = [0,4]
# 输出：4
# 解释：一开始，下标为 1 ，2 和 3 的小朋友没有感冒。总共有 4 个可能的感冒序列：
# - 一开始，下标为 1 和 3 的小朋友可以被传染，因为他们分别挨着有感冒的小朋友 0 和 4 ，令下标为 1 的小朋友先被传染。
# 然后，下标为 2 的小朋友挨着感冒的小朋友 1 ，下标为 3 的小朋友挨着感冒的小朋友 4 ，两位小朋友都可以被传染，令下标为 2 的小朋友被传染。
# 最后，下标为 3 的小朋友被传染，因为他挨着感冒的小朋友 2 和 4 ，感冒序列为 [1,2,3] 。
# - 一开始，下标为 1 和 3 的小朋友可以被传染，因为他们分别挨着感冒的小朋友 0 和 4 ，令下标为 1 的小朋友先被传染。
# 然后，下标为 2 的小朋友挨着感冒的小朋友 1 ，下标为 3 的小朋友挨着感冒的小朋友 4 ，两位小朋友都可以被传染，令下标为 3 的小朋友被传染。
# 最后，下标为 2 的小朋友被传染，因为他挨着感冒的小朋友 1 和 3 ，感冒序列为  [1,3,2] 。
# - 感冒序列 [3,1,2] ，被传染的顺序：[0,1,2,3,4] => [0,1,2,3,4] => [0,1,2,3,4] => [0,1,2,3,4] 。
# - 感冒序列 [3,2,1] ，被传染的顺序：[0,1,2,3,4] => [0,1,2,3,4] => [0,1,2,3,4] => [0,1,2,3,4] 。
# 示例 2：
#
# 输入：n = 4, sick = [1]
# 输出：3
# 解释：一开始，下标为 0 ，2 和 3 的小朋友没有感冒。总共有 3 个可能的感冒序列：
# - 感冒序列 [0,2,3] ，被传染的顺序：[0,1,2,3] => [0,1,2,3] => [0,1,2,3] => [0,1,2,3] 。
# - 感冒序列 [2,0,3] ，被传染的顺序：[0,1,2,3] => [0,1,2,3] => [0,1,2,3] => [0,1,2,3] 。
# - 感冒序列 [2,3,0] ，被传染的顺序：[0,1,2,3] => [0,1,2,3] => [0,1,2,3] => [0,1,2,3] 。
#
#
# 提示：
#
# 2 <= n <= 105
# 1 <= sick.length <= n - 1
# 0 <= sick[i] <= n - 1
# sick 按升序排列。

from leetcode.allcode.competition.mypackage import *

# 带模的组合数
MOD = 1_000_000_007
MX = 100_000

f = [0] * MX  # f[i] = i!
f[0] = 1
for i in range(1, MX):
    f[i] = f[i - 1] * i % MOD

inv_f = [0] * MX  # inv_f[i] = i!^-1
inv_f[-1] = pow(f[-1], -1, MOD)
for i in range(MX - 1, 0, -1):
    inv_f[i - 1] = inv_f[i] * i % MOD

def comb(n: int, m: int) -> int:
    return f[n] * inv_f[m] * inv_f[n - m] % MOD


class Solution:
    def numberOfSequence(self, n: int, sick: List[int]) -> int:
        sick = [-1] + sick + [n]
        seg = []
        ans = 1
        for i, j in pairwise(sick):
            if j <= i + 1: continue
            seg.append(j - i - 1)
            if i != -1 and j != n:
                r1 = pow(2, j - i - 1 - 1, MOD)
                ans = ans * r1 % MOD
        s = sum(seg)
        for i, x in enumerate(seg):
            r2 = comb(s, x)
            ans = ans * r2 % MOD
            s -= x
        return ans


so = Solution()
print(so.numberOfSequence(n = 5, sick = [0,4]))
print(so.numberOfSequence(n = 4, sick = [1]))



