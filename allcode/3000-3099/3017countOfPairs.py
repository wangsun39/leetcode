# 给你三个 正整数 n 、x 和 y 。
#
# 在城市中，存在编号从 1 到 n 的房屋，由 n 条街道相连。对所有 1 <= i < n ，都存在一条街道连接编号为 i 的房屋与编号为 i + 1 的房屋。另存在一条街道连接编号为 x 的房屋与编号为 y 的房屋。
#
# 对于每个 k（1 <= k <= n），你需要找出所有满足要求的 房屋对 [house1, house2] ，即从 house1 到 house2 需要经过的 最少 街道数为 k 。
#
# 返回一个下标从 1 开始且长度为 n 的数组 result ，其中 result[k] 表示所有满足要求的房屋对的数量，即从一个房屋到另一个房屋需要经过的 最少 街道数为 k 。
#
# 注意，x 与 y 可以 相等 。
#
#
#
# 示例 1：
#
#
# 输入：n = 3, x = 1, y = 3
# 输出：[6,0,0]
# 解释：让我们检视每个房屋对
# - 对于房屋对 (1, 2)，可以直接从房屋 1 到房屋 2。
# - 对于房屋对 (2, 1)，可以直接从房屋 2 到房屋 1。
# - 对于房屋对 (1, 3)，可以直接从房屋 1 到房屋 3。
# - 对于房屋对 (3, 1)，可以直接从房屋 3 到房屋 1。
# - 对于房屋对 (2, 3)，可以直接从房屋 2 到房屋 3。
# - 对于房屋对 (3, 2)，可以直接从房屋 3 到房屋 2。
# 示例 2：
#
#
# 输入：n = 5, x = 2, y = 4
# 输出：[10,8,2,0,0]
# 解释：对于每个距离 k ，满足要求的房屋对如下：
# - 对于 k == 1，满足要求的房屋对有 (1, 2), (2, 1), (2, 3), (3, 2), (2, 4), (4, 2), (3, 4), (4, 3), (4, 5), 以及 (5, 4)。
# - 对于 k == 2，满足要求的房屋对有 (1, 3), (3, 1), (1, 4), (4, 1), (2, 5), (5, 2), (3, 5), 以及 (5, 3)。
# - 对于 k == 3，满足要求的房屋对有 (1, 5)，以及 (5, 1) 。
# - 对于 k == 4 和 k == 5，不存在满足要求的房屋对。
# 示例 3：
#
#
# 输入：n = 4, x = 1, y = 1
# 输出：[6,4,2,0]
# 解释：对于每个距离 k ，满足要求的房屋对如下：
# - 对于 k == 1，满足要求的房屋对有 (1, 2), (2, 1), (2, 3), (3, 2), (3, 4), 以及 (4, 3)。
# - 对于 k == 2，满足要求的房屋对有 (1, 3), (3, 1), (2, 4), 以及 (4, 2)。
# - 对于 k == 3，满足要求的房屋对有 (1, 4), 以及 (4, 1)。
# - 对于 k == 4，不存在满足要求的房屋对。
#
#
# 提示：
#
# 2 <= n <= 105
# 1 <= x, y <= n

from leetcode.allcode.competition.mypackage import *

MIN = lambda a, b: b if b < a else a
MAX = lambda a, b: b if b > a else a

class Solution:
    def countOfPairs(self, n: int, x: int, y: int) -> List[int]:
        diff = [0] * (n + 1)
        x, y = x - 1, y - 1
        if x > y: x, y = y, x
        m = y - x + 1  # 环的大小

        def add(from_, unit):
            # 在差分数组，从下标from开始，连续加unit元素，每个增加 1
            to_ = from_ + unit
            diff[from_] += 1
            diff[to_] -= 1

        if m < 3:
            for i in range(n):
                add(1, i)  # [0, i-1]
                add(1, n - (i + 1))  # [i+1, n-1]
            ans = list(accumulate(diff[1:]))
            return ans

        def calc(x, y, flg):
            # 只枚举下标[0,(x + y) // 2]的点，剩下的点利用对称性处理
            for i in range(x):
                add(1, i)   # 处理房屋的编号 [0, i - 1]
                j = (x + y) // 2
                add(1, j - (i + 1) + 1)   # 处理房屋的编号 [i + 1, (x+y)//2]
                add(x - i + 1, n - 1 - y + 1)   # 处理房屋的编号 [y, n - 1]
                add(x - i + 2, y - 1 - j)   # 处理房屋的编号 [(x+y)//2+1,y-1]

            upper = (x + y) // 2 + 1
            if flg == 0 and ((x + y) & 1) == 0:
                upper = (x + y) // 2
            for i in range(x, upper):
                add(i - x + 1, x)   # 处理房屋的编号 [0, x - 1]
                add(MIN(i - x + 2, y - i + 1), n - 1 - y)   # 处理房屋的编号 [y + 1, n - 1]
                # 处理环上的点, (m-1)//2个点都是成对相同的
                add(1, (m - 1) // 2)
                add(1, (m - 1) // 2)
                if (m & 1) == 0:  # 有一个最远点单独处理一下
                    add((m - 1) // 2 + 1, 1)

        calc(x, y, 1)
        calc(n - 1 - y, n - 1 - x, 0)  # 不用处理中间点

        ans = list(accumulate(diff[1:]))
        return ans




so = Solution()
print(so.countOfPairs(n = 3, x = 1, y = 3))




